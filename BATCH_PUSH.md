# Telegram 批量推送功能说明

## 功能概述

为了避免触发 Telegram Bot API 的速率限制，本项目实现了**批量推送机制**：将短时间内收到的多个审核请求合并成一条消息发送。

## 为什么需要批量推送？

### Telegram API 速率限制

Telegram Bot API 有以下限制：
- **全局限制**: 每秒最多 30 条消息
- **同一群组/用户**: 每分钟最多 20 条消息

### 问题场景

当批量导入媒体到 Emby 时（如添加一整季剧集），会快速触发大量 Webhook 事件。如果每个事件都立即发送一条 Telegram 消息：

- ❌ 触发速率限制，消息被延迟或失败
- ❌ 管理员收到大量独立消息，体验差
- ❌ 需要逐个点击审核，效率低

### 批量推送解决方案

✅ 将多个请求收集到队列中
✅ 合并成一条消息批量发送
✅ 避免触发速率限制
✅ 提升管理员审核体验

---

## 工作原理

### 1. 队列机制

```
新媒体添加 → 加入队列 → 等待触发条件 → 批量推送
```

### 2. 触发条件

批量推送会在以下任一条件满足时触发：

| 条件 | 默认值 | 说明 |
|------|--------|------|
| 时间阈值 | 30 秒 | 距上次推送超过此时间 |
| 数量阈值 | 10 条 | 队列中的请求数量达到此值 |

### 3. 消息格式

**单次推送前（独立消息）**:
```
🎬 CDN 预热审核请求

📝 请求 ID: 123
🎞 媒体名称: 测试电影 1
📂 类型: Movie
...

[✅ 同意预热] [❌ 拒绝]
```

**批量推送后（合并消息）**:
```
🎬 CDN 预热审核请求（共 5 项）

1. 🎬 测试电影 1 (ID: 101)
2. 🎬 测试电影 2 (ID: 102)
3. 📺 测试剧集 S01E01 (ID: 103)
4. 📺 测试剧集 S01E02 (ID: 104)
5. 🎬 测试电影 3 (ID: 105)

💡 使用下方按钮批准或拒绝每个项目

[✅ 测试电影 1] [❌]
[✅ 测试电影 2] [❌]
[✅ 测试剧集 S01E01] [❌]
[✅ 测试剧集 S01E02] [❌]
[✅ 测试电影 3] [❌]
```

### 4. 分批发送

如果队列中的请求超过 `MAX_ITEMS_PER_MESSAGE`（默认 5 条），会自动分批发送：

- 第一批: 5 条
- 第二批: 5 条
- ...
- 批次间延迟 1 秒，避免速率限制

---

## 配置参数

在 `.env` 文件中配置以下参数：

```bash
# 批量推送时间间隔（秒）
BATCH_PUSH_INTERVAL=30

# 批量推送最大数量（达到此数量立即推送）
BATCH_PUSH_SIZE=10

# 单条消息最多包含的媒体数量
MAX_ITEMS_PER_MESSAGE=5
```

### 参数说明

| 参数 | 默认值 | 建议范围 | 说明 |
|------|--------|----------|------|
| `BATCH_PUSH_INTERVAL` | 30 秒 | 10-60 秒 | 时间越长，批量效果越好，但延迟增加 |
| `BATCH_PUSH_SIZE` | 10 条 | 5-20 条 | 数量越大，批量效果越好，但单次消息更长 |
| `MAX_ITEMS_PER_MESSAGE` | 5 条 | 3-10 条 | 受 Telegram 消息长度限制，不建议超过 10 |

### 配置建议

**场景一：小规模使用（偶尔添加媒体）**
```bash
BATCH_PUSH_INTERVAL=10  # 更快响应
BATCH_PUSH_SIZE=5       # 较小批次
MAX_ITEMS_PER_MESSAGE=5
```

**场景二：中等规模（经常添加剧集）**
```bash
BATCH_PUSH_INTERVAL=30  # 默认配置
BATCH_PUSH_SIZE=10
MAX_ITEMS_PER_MESSAGE=5
```

**场景三：大规模批量导入**
```bash
BATCH_PUSH_INTERVAL=60  # 更长间隔
BATCH_PUSH_SIZE=20      # 更大批次
MAX_ITEMS_PER_MESSAGE=10
```

---

## 测试批量推送

### 1. 使用测试脚本

项目提供了 `test_batch_push.py` 测试脚本：

```bash
# 批量测试（发送 8 个媒体）
python test_batch_push.py

# 单项测试
python test_batch_push.py single
```

### 2. 预期行为

运行批量测试后：

1. **服务日志**（`webhook.log`）:
   ```
   📥 审核请求已加入队列: ID=101, 队列大小=1
   📥 审核请求已加入队列: ID=102, 队列大小=2
   ...
   🔔 触发批量推送: 队列大小达到 10, 队列大小=10
   📤 准备推送 10 个审核请求
   ✅ 批量消息发送成功: chat_id=xxx, 包含 10 个请求
   ```

2. **Telegram Bot**:
   - 收到一条或多条合并消息（取决于 `MAX_ITEMS_PER_MESSAGE`）
   - 每个媒体有独立的批准/拒绝按钮
   - 点击按钮后正常完成审核流程

---

## 后台任务机制

### 批量推送工作流程

```python
async def _batch_push_worker(self):
    """
    后台任务：每 5 秒检查一次队列
    """
    while True:
        await asyncio.sleep(5)

        queue_size = self.review_queue.qsize()
        if queue_size == 0:
            continue

        # 判断是否需要推送
        if queue_size >= BATCH_PUSH_SIZE:
            # 条件 1: 数量达到阈值
            await self._push_batch_from_queue()
        elif time_elapsed >= BATCH_PUSH_INTERVAL:
            # 条件 2: 时间达到阈值
            await self._push_batch_from_queue()
```

### 启动和停止

- **自动启动**: Bot 初始化时自动启动后台任务
- **优雅关闭**: Bot 关闭时自动取消后台任务

---

## 日志查看

批量推送相关的日志：

```bash
# 实时查看日志
tail -f webhook.log

# 过滤批量推送相关日志
grep "批量\|队列" webhook.log
```

### 关键日志标识

| 日志 | 说明 |
|------|------|
| `📥 审核请求已加入队列` | 请求加入队列 |
| `🚀 队列达到最大数量` | 触发立即推送 |
| `🔔 触发批量推送` | 开始批量推送 |
| `📤 准备推送 X 个审核请求` | 推送开始 |
| `✅ 批量消息发送成功` | 推送成功 |
| `❌ 发送批量消息失败` | 推送失败 |

---

## 优势对比

### 推送前 vs 推送后

| 对比项 | 批量推送前 | 批量推送后 |
|--------|-----------|-----------|
| **消息数量** | 10 个媒体 = 10 条消息 | 10 个媒体 = 1-2 条消息 |
| **触发限制风险** | ⚠️ 高（快速导入时） | ✅ 低（有效控制） |
| **管理员体验** | ❌ 收到大量独立消息 | ✅ 集中显示，易于批量处理 |
| **审核效率** | ❌ 需要逐个点击 | ✅ 可快速浏览和决策 |
| **响应延迟** | ✅ 立即（< 1 秒） | ⚠️ 有延迟（最多 30 秒） |

---

## 常见问题

### Q: 批量推送会影响响应速度吗？

A: 会有轻微延迟（最多 `BATCH_PUSH_INTERVAL` 秒），但不影响 Webhook 响应。建议根据使用场景调整配置：
- 小规模使用：减小 `BATCH_PUSH_INTERVAL`（如 10 秒）
- 大规模导入：增大 `BATCH_PUSH_INTERVAL`（如 60 秒）

### Q: 如何禁用批量推送？

A: 批量推送是内置机制，无法完全禁用。但可以通过配置实现类似效果：
```bash
BATCH_PUSH_INTERVAL=1   # 1 秒立即推送
BATCH_PUSH_SIZE=1       # 单个请求立即推送
MAX_ITEMS_PER_MESSAGE=1 # 每条消息只包含 1 个媒体
```

**注意**: 不建议禁用，容易触发速率限制。

### Q: 队列中的请求会丢失吗？

A: 不会。队列存储在内存中，只要服务运行，请求不会丢失。但如果服务重启，未推送的队列会丢失（请求已保存在数据库中）。

### Q: 批量消息中的按钮如何工作？

A: 每个媒体有独立的批准/拒绝按钮。点击任一按钮后：
1. 只处理对应的请求
2. 其他请求不受影响
3. 整条消息仍然保留，方便继续审核

---

## 实现细节

### 核心代码位置

| 文件 | 相关代码 | 说明 |
|------|----------|------|
| `telegram_bot.py` | `add_to_queue()` | 添加请求到队列 |
| `telegram_bot.py` | `_batch_push_worker()` | 后台任务，定期检查队列 |
| `telegram_bot.py` | `_push_batch_from_queue()` | 从队列取出并推送 |
| `telegram_bot.py` | `_send_batch_reviews()` | 构建批量消息并发送 |
| `webhook_server.py` | `process_media_item()` | 调用 `add_to_queue()` |
| `config.py` | 配置参数 | `BATCH_PUSH_*` 参数 |

### 技术实现

- **队列**: `asyncio.Queue`（线程安全）
- **后台任务**: `asyncio.create_task()`
- **定时检查**: `asyncio.sleep(5)` 每 5 秒检查一次
- **消息合并**: 使用列表拼接多个媒体信息
- **按钮布局**: InlineKeyboardMarkup，每行 2 个按钮（批准 + 拒绝）

---

## 总结

批量推送机制有效解决了 Telegram API 速率限制问题，提升了批量导入场景下的使用体验。通过合理配置参数，可以在响应速度和批量效果之间找到平衡。

**推荐配置**:
- `BATCH_PUSH_INTERVAL=30`
- `BATCH_PUSH_SIZE=10`
- `MAX_ITEMS_PER_MESSAGE=5`

如有问题或建议，请查看项目文档或提交 Issue。
